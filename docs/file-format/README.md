# Cobol Sequential File Format

The Cobol Sequential File Format is made up of records that are meant to be read in sequential order. The layout of each record is defined by a Cobol copybook and can be fixed or variable in length. The Cobol programming language even has built in support for reading and writing data to files in this format.

If you have the correct copybook and you know the byte range in the file for the record it is fairly straight-forward to extract values from a record for specific fields.

## Purpose of this document

In this document we will outline our current understanding of the sequential file format. This should
be a living document and should be updated as our understanding evolves. This document is also accompanied by [example files](example-files/) that have been generated by cobol programs.

## Copybooks & Record Layouts

A Cobol Copybook is typically a section of a Cobol program that describes the fields, data types, and order that data should be stored inside of a record.
These program sections are frequently refactored out of the main cobol program to
a separate file so that they can be shared across multiple cobol programs.

A very simple Copybook may look like this:

```CPY
       01 TRANSACTION-RECORD.
           02 UID PIC 9(5).
           02 DESC PIC X(25).
           02 DETAILS.
            03 AMOUNT PIC 9(6)V9(2).
            03 START-BALANCE PIC 9(6)V9(2).
            03 END-BALANCE PIC 9(6)V9(2).
           02 ACCOUNT-ID PIC 9(7).
           02 ACCOUNT-HOLDER PIC X(50).
```

In the example above you have a group of fields called a `TRANSACTION-RECORD`. That
group contains a 5 digit field called `UID`, a 25 character field called `DESC`, 7 digit field for an `ACCOUNT-ID`, and a 50 character field for an `ACCOUNT-HOLDER`.

The group also contains a nested group that
has it's own fields. The `AMOUNT`, `START-BALANCE`, and `END-BALANCE` fields are decimal fields that have 6 digits to the left of the decimal and 2 digits to the right of the decimal.

Every field or group in a copybook has a level assigned to it that helps identify the
hierachy of the fields in the copybook.
So for fields to be included under the `TRANSACTION-RECORD` they must have a higher level assigned to them such as 2, 3, 5, etc.

When data for these fields are written to a file the fields are always written in the order that they are defined in the copybook.
Take a look at this example of values and byte positions and compare it to the file output.

| field          | byte range   | value                |
| -------------- | -------------|----------------------|
| UID            | 1-5          | 12345                 |
| DESC           | 6-30         | TEST TRANSACTION      |
| AMOUNT         | 31-38        | 000124.34             |
| START-BALANCE  | 39-46        | 000177.54             |
| END-BALANCE    | 47-54        | 53.2                  |
| ACCOUNT-ID     | 55-62        | empty                 |
| ACCOUNT-HOLDER | 63-102       | empty                 |
*empty here means that the byte range is full of empty spaces*

```txt
12345TEST TRANSACTION         0001243400017754000053200000000                                                  
```

[full example file](example-files/record-sequential-simple.dat)

### Occurs Clause

In a copybook an Occurs clause means that a field or group of fields can repeat multiple times within the same record. We can modify the previous example to repeat the details group 3 times:

```CPY
       01 TRANSACTION-RECORD.
           02 UID PIC 9(5).
           02 DESC PIC X(25).
           02 DETAILS OCCURS 3 TIMES.
            03 AMOUNT PIC 9(6)V9(2).
            03 START-BALANCE PIC 9(6)V9(2).
            03 END-BALANCE PIC 9(6)V9(2).
           02 ACCOUNT-ID PIC 9(7).
           02 ACCOUNT-HOLDER PIC X(50).
```

Using the same field values as the example above a record would look like this when written to a file:

```TXT
12345TEST TRANSACTION         0001243400017754000053200001243400017754000053200001243400017754000053200000000                                                  
```

[full example file](example-files/record-sequential-with-occurs.dat)

The key difference to notice here is that the Details group is being repeated. So you can see the fields in order `AMOUNT 1 -> START-BALANCE 1 -> END-BALANCE 1 -> AMOUNT 2 -> START-BALANCE 2 -> etc`.

### Redefines

I won't go into as much detail for redefines. But the general idea is that you can define a new field name that references the memory location of an existing field.

Redefine fields can also reference a subset of the memory of the original field. This is kind
of like performing a substring operation of a field without copying it. You can read more about it [here](https://www.tutorialbrain.com/mainframe/cobol-redefines/)

This does not seem like a feature that we need to support in a POC or MVP because the data representation that we choose should provide developers the utilities they need to reproduce the redefine fields. It could be an interesting feature to have in a future version so that developers would not need to reproduce the redefine fields but we would have to think about if
there is a way to do this without copying the data.

### Level 88

Level 88 statements allow developers to specify potential values for a field and associate them with a label. 88 statements do not have to be exhaustive so values that aren't defined can still be stored in the field. You can read more about them [here](https://www.ibm.com/docs/en/record-generator/3.0?topic=division-condition-name-level-88-statements)

This seems like a difficult feature to reproduce in another intermediate data representation. Since
the values are not exhaustive it also seems a bit mute to figure out how to implement so it probably does not need to be focused on in an early release.

## File Organisations

The Cobol programming language provides multiple variations of this file format which they typically
refer to as "File Organisations". These Organisations are:

- Sequential Files (Record Sequential)
- Line Sequential Files
- Relative Files
- Indexed Files

### Sequential Files (Record Sequential)

Record Sequential files are sometimes just referred to as Sequential files because Record Sequential is the default sequential organisation and the default file organisation for COBOL.

They contain fixed length records and sometimes a variable number of record layouts. Documentation around this organization can be somewhat misleading about this. The term "variable" is frequently used to describe the record length but COBOL **DOES NOT ALLOW VARIABLE LENGTH RECORDS IN THIS ORGANISATION**. What can be variable here is the number of record layouts.

Record Sequential files typically do not have a record delimiter which can make reading them more difficult. Re-using the same copybook and values from the `Copybooks & Record Layouts` section a
record sequential file would look like [this example](example-files/record-sequential-simple.dat):

```TXT
12345TEST TRANSACTION         0001243400017754000053200000000                                                  12345TEST TRANSACTION         0001243400017754000053200000000                                                  
```

### Line Sequential Files

The records in these files are normally variable length and are separated by a record delimiter. If a record delimiter is reached before the last field the parser should consider the remaining fields in the record empty.

For this example we will use this copybook:

```CPY
       01 TRANSACTION-RECORD.
           02 UID PIC 9(5).
           02 DESC PIC X(25).
           02 ACCOUNT-ID PIC 9(7).
           02 ACCOUNT-HOLDER PIC X(50).
```

With this copybook if we populated the fields with the following values they would have the corresponding byte ranges in the record:
| field          | byte range   | value                |
| -------------- | -------------|----------------------|
| UID            | 1-5          | 12345                |
| DESC           | 6-30         | empty                |
| ACCOUNT-ID     | 31-37        | 9876543              |
| ACCOUNT-HOLDER | N/A          | empty                |

You should notice that in the table above the first empty field `DESC` still reserves bytes for the field even though it's empty. Only the last empty field `ACCOUNT-HOLDER` is truncated from the record, this means only consecutive empty fields at the end of variable length record will conserve space. You will also see this in a file where we wrote two records:

```TXT
12345                         9876543$
12345                         9876543$
```

[full example file](example-files/line-sequential-simple.dat)

Here `$` represents a Unix line ending `\n` or LF. But the documentation does state that on some other systems the delimiter will be a carriage return and a line feed character.

### Relative Files

The records in a relative file always have a fixed-length. A relative file has a numeric number assigned to every record, this number represents the position of the record relative to the begining of the file. So for example if you
wanted a record to be the 6th record in a file you would specify 6 as the value for the key. This allows a parser that is aware of the record length to skip to that byte-offset and read only the 6th record.

This also means that there can be "gaps" in the file. So for example if only records 1, 2, and 4 were written to the file
then the space for record 3 would be zeroed out.

Let's show an example of this, if we had this copybook:

```CPY
       01 TRANSACTION-RECORD.
           02 UID PIC 9(5).
           02 DESC PIC X(25).
           02 ACCOUNT-ID PIC 9(7).
           02 ACCOUNT-HOLDER PIC X(50).
```

with the UID set as the key for this example we also populated the UIDs for each record as `00010`, `00020`, `00040`.

```TXT
W^@^@^@^@^@^@^@00010                         9876543                                                  W^@^@^@^@^@^@^@00020                         9876543                                                  ^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@W^@^@^@^@^@^@^@00040                         9876543                                                  
```

[full example file](example-files/relative-simple.dat)

You should notice that bytes 191-286 contain Non-Printable characters. This section of the file is meant to hold a record with the key `3` but since we never wrote one the bytes have been zeroed out.

Our record length is 87 characters so it almost fills the full gap of 95 characters of Non-Printable characters. It seems that COBOL is prefixing each record with 8 additional bytes.

Upon further inspection, If the record is populated the first byte will be `W` and the next 7 bytes will be a binary 0 value which tends to show up as an Non-printable character in most text editors. If a record is not populated all bytes
will be reserved with a binary 0 value. This does seem to allow a parser to identify which spaces have been  populated.

I'm still looking for documentation that confirms this behavior but it does seem to make sense.

Now this file organization is a bit more specialized than the other two I have looked at. It could be useful to provide the ability to read these files sequentially so that developers can gain access to them, but I'm not sure if there is value in this project providing random access to these files since it seems like once you read them sequentially you could load them into a datastore that manages that for you. Although, I suppose you may need to keep the key values with the record to maintain compatibility in some scenarios.

### Indexed Files

Indexed files have a key field that allows COBOL to access records randomly or sequentially. Records can be fixed length or variable. COBOL always writes the index to a file separate from the data.

Since the data is typically written to a separate sequential file. I am not going to spend too much time on this file organization because if you had parser that supported Record Sequential, Line Sequential, or Relative you should still
be able to parse the data in these. It could be interesting to explore a feature that enables random lookups
in a file with the Index but that may not be
in scope for this project.

## Multiple Record Layouts

It is possible for a copybook to define multiple record layouts and for a COBOL program to alternate record layouts in a sequential file. This can make a file format highly customized and difficult to parse. In order to be able to parse one of these files you should look at additional characteristics of the data such as a count field that defines the number of the next records to expect in the other layout or an indicator field that exists on each record type where it's value indicates a specific record layout.

### Record Sequential Example

```CPY
       01 TRANSACTION-RECORD.
           02 UID PIC 9(5).
           02 DESC PIC X(25).
           02 ACCOUNT-ID PIC 9(7).
           02 ACCOUNT-HOLDER PIC X(50).
           02 DETAIL-COUNT PIC 9(5).
       01 TRANSACTION-DETAIL.
           02 AMOUNT PIC 9(6)V9(2).
           02 START-BALANCE PIC 9(6)V9(2).
           02 END-BALANCE PIC 9(6)V9(2).
```

Using the same field values as the examples above a transaction record with 3 transaction details could look like this when written to a file:

```TXT
^@\^@^@12345TEST TRANSACTION         0000000                                                  00003^@^X^@^@000124340001775400005320^@^X^@^@000124340001775400005320^@^X^@^@000124340001775400005320^@\^@^@
```

[full example file](example-files/record-sequential-multi-layout.dat)

A parser could use the count field to determine the number of TRANSACTION-DETAILs to expect after
the TRANSACTION-RECORD.

You may also notice that each record is prefixed with Non-Printable characters `^@`, `^X`, and `\`. These are part of the Record Length Prefix.

#### Record Length Prefixes

The record length prefix in this case is actually a 2-byte big-endian integer that represents the length of the record. If you use `xxd -b` to view the first 4 bytes of the file you will see `00000000 01011100 00000000 00000000`. After brushing up on [big endian](https://www.geeksforgeeks.org/little-and-big-endian-mystery/) you will see that the value is `92`. That matches the length of our `TRANSACTION-RECORD` perfectly.

If we look past the `TRANSACTION-RECORD` in the file we will see the byte sequence `00000000 00011000 00000000 00000000` the first two bytes translate to `24` which matches the length of the `TRANSACTION-DETAIL` record as well.

##### Variations in Size

If you look closely at some of the [documentation for the GnuCobol](https://github.com/ayumin/open-cobol) compiler you will notice this excerpt

```TXT
--with-varseq=<n>  Define the format for variable length sequential
    files.

    For values of 0, 1 and 2, four bytes are
    written preceding each record. The format of
    these four bytes for values of 0, 1, 2 is
    as follows :
    n = 0 (default)
     The first 2 bytes are the record length
     in big-endian order. This is compatible
     with mainframe. Bytes 3 and 4 are set
     to binary 0.
    n = 1
     The 4 bytes are the record length in
     big-endian order.
    n = 2
     The 4 bytes are the record length in
     native machine order (int).
     (This was previously the default)

    For the value of 3, two bytes are written
    preceding each record :
    n = 3
     The first 2 bytes are the record length
     in big-endian order. The record follows
     immediately after beginning at byte 3.
```

Just with the GnuCobol compiler you can see that you can change the size of the record length prefix.
It does seem like it could be possible that other compilers could have additional variations but I
haven't found firm documentation to support that.

##### Should they be used for parsing?

So an additional option for parsing multiple record layouts is to read the record length prefix and lookup which record layout matches that length. But this will only work under two conditions:

- The file must be of RECORD SEQUENTIAL organization.
- The record layouts must be have different lengths.
  - If all the record layouts are the same length then COBOL will not output the record length prefix.

Relying on this approach may not be great because as the schema evolves there is some chance that record layouts that were not previously the same length could become the same length. Forcing you to change your parsing mechanism. This prefix is not well known either. If your data is passing through multiple hands before it reaches you, it is possible that these bytes could be stripped out or converted to something else and lose their meaning.

The prefix could definitely be useful for doing validation on a file but it may be better to rely on other characteristics of the data first.

### Line Sequential Example

Line Sequential files can also have multiple record layouts. These files are often easier to view with text editors because unlike having multiple record layouts in a record sequential file there is no record length prefix! This is because each record in the file is separated by the same record delimiter. For example, if you have the following record layouts where the `TRANSACTION-RECORD` always preceds a `TRANSACTION-DETAIL` your copybook could look like this:

```CPY
       01 TRANSACTION-RECORD.
           02 REC-IND PIC X(1).
           02 UID PIC 9(5).
           02 DESC PIC X(25).
           02 ACCOUNT-ID PIC 9(7).
           02 ACCOUNT-HOLDER PIC X(50).
       01 TRANSACTION-DETAIL.
           02 REC-IND PIC X(1).
           02 AMOUNT PIC 9(6)V9(2).
           02 START-BALANCE PIC 9(6)V9(2).
           02 END-BALANCE PIC 9(6)V9(2).
```

And the output in the file would look like this:

```TXT
T12345TEST TRANSACTION         0000000$
D000124340001775400005320$
D000124340001775400005320$
D000124340001775400005320$
```

The newline characters are a lot easier on the eyes and it is fairly easy to pick out different records. But without the record length prefix you **MUST** use some application specific business logic in order to distinguish which record layout is associated with each record. For this example, I created a `REC-IND` field at the begining of each record layout. If the
value is `T` then the record is a `TRANSACTION-RECORD` but if the value is `D` it is a `TRANSACTION-DETAIL` record.

There are many ways that a COBOL application could be identifying records, some methods I have identified so far are:

- expected trailer record count field
- record identifier field
- record length (this is not a good idea with variable length records or line sequential files)
